<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
	<script>
		/**
		 *
		 * Lesson 2, Classwork, Serhii Yakubovych
		 * 
		 */
		
		 /**
		  * ###Задача 1. 
		  */

		/*
		Каков будет результат выполнения этого кода?
		```
		var value = 0;
		function f() {
		  if (1) {
		    value = true;
		  } else {
		    var value = false;
		  }
		  alert( value );
		}
		f();
		```
		Изменится ли внешняя переменная value ?
		Как изменится рузультат, если из строки var value = false убрать ключевое слово var?

		Ответ:
		
		- Результатом выполнения будет вывод моульного окна alert с текстом true.

		- Изменится ли внешняя переменная value ? Нет, у функции f() будет создана локальная переменная value.

		- Как изменится рузультат, если из строки var value = false убрать ключевое слово var? Внешняя переменная перезапишется и станет равна false.

		 */
		
		/**
		 * ###Задача 2. 
		 * 
		 * Напишите функцию, возвращающую количество собственных вызовов.
		 */
		
		var selfCounter = (function() {
			var invokeCount = 0;
			return function() {
				return ++invokeCount;
			}
		})();

		console.log( selfCounter() );
		console.log( selfCounter() );
		console.log( selfCounter() );

		/**
		 * ###Задача 3.
		 */
		
		/*
		Следующий код создает массив функций-стрелков shoooters. По замыслу, каждый стрелок должен выводить свой номер: 
		```
		function makeArmy() {
			var shooters = []; 

			for (var i = 0; i< 10; i++) {
			    var shooter = function() { // функция-стрелок
					alert(i); // выводит свой номер
				}; 
				shooters.push(shooter); 
			} 
			return shooters; 
		}
		var army = makeArmy(); 
		army[0](); // стрелок выводит 10, а должен 0
		army[5](); // стрелок выводит 10, а должен 5. 

		```
		Сейчас все функции-стрелки выводят 10 вместо своего номера. 
		Поправьте код, чтобы при вызове каждой из них она выводила свой номер(индекс в массиве). 
		Предложите несколько вариантов. 
		 */
		
		// Вариант 1. Использование let вместо var
		// (переменная обьявленная с помощью let имеет локальную область видимости и создается при каждой итерации заново):
		function makeArmy() {
			var shooters = [],
				shooter; 

			for (let i = 0; i< 10; i++) {
			    shooter = function() { // функция-стрелок
					alert(i); // выводит свой номер
				}; 
				shooters.push(shooter); 
			} 
			return shooters; 
		}
		var army = makeArmy(); 
		army[0]();
		army[5]();

		// Вариант 2. Использование самовызывающейся функции
		function makeArmy2() {
			var shooters = [],
				shooter; 

			for (let i = 0; i< 10; i++) {
			    shooter = (function(i) { // функция-стрелок
			    	return function() {
			    		alert(i); // выводит свой номер
			    	}
				}(i)); 
				shooters.push(shooter); 
			} 
			return shooters; 
		}
		var army2 = makeArmy(); 
		army2[0]();
		army2[5]();
	</script>

</body>
</html>